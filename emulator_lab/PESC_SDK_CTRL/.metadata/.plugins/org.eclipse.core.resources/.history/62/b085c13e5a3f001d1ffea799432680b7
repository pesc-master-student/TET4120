#include "ConfigParameters.hpp"
extern ConfigParameters Parameters;

#include "SwLoadEmulator.hpp"


void LoadEmulator::Initialize(void){

	m_LoadType 	= static_cast<LoadType>(Parameters.Load1.LoadType);
	m_T_load_Nm =0.0;

	m_PumpData.k_L			= Parameters.Load1.Pump.k_L;
	m_PumpData.t_constant	= Parameters.Load1.Pump.t_constant;

}


fp32_t& LoadEmulator::Run(const fp32_t& Actual_Speed_rpm){

	m_T_load_Nm=0.05;
	switch (m_LoadType){
			case LoadType::Pump:
				m_T_load_Nm=RunPump(Actual_Speed_rpm);
				return m_T_load_Nm;
				break;
			case LoadType::ElectricVehicle:
				m_T_load_Nm =0.2;
				return m_T_load_Nm;
				break;
			case LoadType::ShipPropulsion:
				m_T_load_Nm=0.3;
				return m_T_load_Nm;
				break;
			case LoadType::WindPower:
				m_T_load_Nm=0.4;
				return m_T_load_Nm;
				break;
			case LoadType::HydroPower:
				m_T_load_Nm=0.5;
				return m_T_load_Nm;
				break;
			default:
				// Should we trip the drive ??
				m_T_load_Nm=0.0;
				return m_T_load_Nm;
				break;
		}



}


const fp32_t LoadEmulator::RunPump(const fp32_t ActSpeed_rpm){
	fp32_t t_pump_Nm;

	if (ActSpeed_rpm >=0.0){
		t_pump_Nm=m_PumpData.k_L*ActSpeed_rpm*ActSpeed_rpm+m_PumpData.t_constant;
	}
	else {
		t_pump_Nm=-m_PumpData.k_L*ActSpeed_rpm*ActSpeed_rpm+m_PumpData.t_constant;
	}

	return t_pump_Nm;
}
