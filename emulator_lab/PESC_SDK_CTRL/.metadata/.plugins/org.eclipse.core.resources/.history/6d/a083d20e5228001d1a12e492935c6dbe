
/************************************************************************************

File Name: 		Drive.cpp
Description:	Implementation code. Further details explained in Drive.hpp

NOTE:  This version is for DC Drives

*************************************************************************************/


#include <Drive.hpp>


const bool Drive::resetFaultWord(void){
// To be improved . Should call converter routines as well
	  m_uFaultWord.all = 0x0000;
	  m_uStatusWord.all = 0x0000;

	  if (Converter1.resetFaultWord()&Converter1.resetFaultWord()){
		  b_Reset_Fault_Status=true;
	  }
	  else {
		  b_Reset_Fault_Status=false;
	  }

	  return b_Reset_Fault_Status;
}

void Drive::initialize(){

	m_udc_test = 1.0;
	m_speed_max = 1.5;
	m_speed_rate_sign = 1.0;

	m_i.a_avg_old    = 0.0;

	m_MACHINE_ID     = Parameters.Drive1.MotorData.MACHINE_ID ;             //
	m_Udc1_Startup_V = Parameters.Drive1.DriveData.Udc_conv1_StartLim_V;
	m_Udc2_Startup_V = Parameters.Drive1.DriveData.Udc_conv2_StartLim_V;
	m_UfN            = Parameters.Drive1.MotorData.UfN_V;
	m_UaN			 = Parameters.Drive1.MotorData.UaN_V;
	m_Uabasis        = Parameters.Drive1.MotorData.Uabasis_V;
	m_1_div_IaN		 = 1.0 / Parameters.Drive1.MotorData.IaN_A;
	m_1_div_IfN		 = 1.0 / Parameters.Drive1.MotorData.IfN_A;
	m_1_div_UfN      = 1.0 / m_UfN;
	m_1_div_Uabasis  = 1.0 / m_Uabasis;
	m_1_div_UaN		 = 1.0 / m_UaN;
	m_1_div_Nrpmbasis = 1.0/Parameters.Drive1.MotorData.Nn_rpm;
	m_Tbasis_Nm		 = m_Uabasis * Parameters.Drive1.MotorData.IaN_A /( Parameters.Drive1.MotorData.Nn_rpm * M_PI / 30.0 );

	m_TrefLim.initialize(m_1_div_Uabasis); // Inverse of Udc-basis required
	m_te.max_used=m_TrefLim.Tmax_k;
	m_te.min_used=m_TrefLim.Tmin_k;

	// Reading of machine parameters and calculation of basis-values:

	m_DC.par.ra		 = Parameters.Drive1.MotorData.ra;
	m_DC.par.la		 = Parameters.Drive1.MotorData.la;
	m_Ta			 = m_DC.par.la / fmax(m_DC.par.ra, 0.0001);
	m_DC.par.Tf		 = Parameters.Drive1.MotorData.Tf;
	FieldCurrentController.SetParameters(m_DC.par.Tf/(5.0*Tsamp), m_DC.par.Tf, 0.1 * m_DC.par.Tf,0.0, Tsamp);
	ArmatureCurrentController.SetParameters(m_DC.par.la /(4.0*Tsamp), m_Ta, 0.1*m_Ta,1.0, Tsamp);

	m_DC.par.iamax0   = Parameters.Drive1.MotorData.iamax_pu;
	m_DC.par.ifmax0   = Parameters.Drive1.MotorData.ifmax_pu;
	m_i.limit_motor1  = m_DC.par.iamax0;
	m_i.limit_motor2  = m_DC.par.ifmax0;
	m_te.max_Current1 = 1.0;
	m_ua_fw			  = 1.0+m_DC.par.ra;
	m_i.limit_converter1 = m_1_div_IaN*Parameters.Converter1.Limit.Ia_A;
	m_i.limit_converter2 = m_1_div_IfN*Parameters.Converter1.Limit.Ic_A;
	m_Converter1_Topology= Parameters.Converter1.Converter_Topology;

	m_SpeedFilter.InitValue(0.0);
	m_SpeedFilter.SetParameters(Parameters.Drive1.DriveData.Time_SpeedFilter, Tsamp); // 3 ms time constant

	m_theta_offset=0.0;

}

void Drive::PreCharge(const bool Relay_on){
// Controlling the pre-charge relays for the converters
	b_Precharge_On_Converter1=Relay_on;
	b_Precharge_On_Converter2=Relay_on;
}

const uint16_t Drive::ReadyToStart(){
	m_Bit_Status = m_uStatusWord.bit.ready_to_start;
	return m_Bit_Status;
}

const uint16_t Drive::ReadyForOperationEnable(){
	m_Bit_Status = m_uStatusWord.bit.ready_for_operation_enable;
	return m_Bit_Status;
}

const ValueActual Drive::GetValues(){

	m_actualvalues.te_ref_used = m_te.ref_used;
	m_actualvalues.te_actual = m_te.actual;
	m_actualvalues.speed = m_speed_pu;
	m_actualvalues.speed_filtered = m_speed_filtered_pu;
	m_actualvalues.te_max_used = m_te.max_used;
	m_actualvalues.te_min_used = m_te.min_used;
	return m_actualvalues;
}


void Drive::SetValues(ValueRef References){ // Get references and limits from Application Layer into  Drive Layer

	m_te.ref_input	=	References.te_ref;
	m_te.max		=	References.te_max;
	m_te.min		=	References.te_min;
	m_p.max			=	abs(References.p_max);
	m_p.min			=  -abs(References.p_min);

}

const uDriveFaultWord Drive::GetFaults(){
	return m_uFaultWord;
}

const uDriveWarningWord Drive::GetWarnings(){
	return m_uWarningWord;
}
const uDriveLimitWord Drive::GetLimits(){
	return m_uLimitWord;
}

void Drive::getMeasurements(){

	m_conv1 = Converter1.getMeasurements();
	m_conv2 = Converter2.getMeasurements();
}


const uint16_t Drive::getStatus(const uint16_t conv1, const uint16_t conv2){
	uint16_t drive_has_tripped;

	if ((!conv1)&(!conv2)){
		drive_has_tripped = false;

	}
	else{ // Only SET Fault-bit. Never clear it.
		drive_has_tripped = true;
		if (conv1) m_uFaultWord.bit.converter_1 = true;
		if (conv2) m_uFaultWord.bit.converter_2 = true;
	}

	return drive_has_tripped;
}




void Drive::RequestState(enum DriveState drive_status){
	// Here conditions for changing the state has to be considered and m_state given the proper value

	switch (drive_status){
			case DriveState::Disabled:
				m_state = DriveState::Disabled;
				break;
			case DriveState::Starting:
				m_state = DriveState::Starting;
				break;
			case DriveState::OperationEnabled:
				m_state = DriveState::OperationEnabled;
				break;
			case DriveState::TestRun:
				m_state = DriveState::TestRun;
				break;
			default:
				m_state = DriveState::Disabled;
				break;
		}

}

void Drive::run() {

	getFaultAndWarnings();  // From Converters
	if (m_uFaultWord.all !=0){
			m_state = DriveState::Disabled;
	}

	// calculation of pu-values of measured currents and voltages in armature:
	m_u.dc1			= m_conv1.U_dc_avg_V*m_1_div_Uabasis;
	m_u.a			= (m_conv1.U_a0_avg_V - m_conv1.U_b0_avg_V)*m_1_div_Uabasis;
	m_ua_max 		= m_conv1.U_peak_max_V * m_1_div_Uabasis;
	m_i.a_avg_old   = m_i.a_avg;
	m_i.a_avg   	= m_conv1.I_sa_avg_A * m_1_div_IaN;
	m_i.a_MA		= 0.5*(m_i.a_avg+m_i.a_avg_old);
	m_i.a_LP   		= m_conv1.I_sa_A * m_1_div_IaN;
	m_i.a			= m_i.a_MA; //Chosen feedback from MA

	// calculation of pu-values of measured current and voltage in field winding:
    // Only converter 1 is used for FB+HB
	m_u.dc2			= m_conv1.U_dc_avg_V*m_1_div_UfN;
	m_u.f			= m_conv1.U_c0_avg_V*m_1_div_UfN;
	m_uf_max 		= m_conv1.U_peak_max_V * m_1_div_UfN; // ???
	m_i.f_avg_old   = m_i.f_avg;
	m_i.f_avg   	= m_conv1.I_sc_avg_A * m_1_div_IfN;
	m_i.f_MA		= 0.5*(m_i.f_avg+m_i.f_avg_old);
	m_i.f_LP   		= m_conv1.I_sc_A * m_1_div_IfN;
	m_i.f			= m_i.f_MA; //Chosen feedback from MA

	// Speed and position measurements if encoder is available:

	m_speed_rpm 	 = FirmWare1.getSpeed(PhysicalMode);
	m_abs_theta_mech = FirmWare1.getAbsPosition(PhysicalMode);  // gets Absolute mechanical position from Encoder
	m_theta_mech 	 = FirmWare1.getPosition(PhysicalMode);  // gets free mechanical position from Encoder. Used only during startup

	m_speed_pu		= m_SpeedFilter.Run(m_speed_rpm * m_1_div_Nrpmbasis) ;

	//m_inv_speed_pu = 1.0/fmax(abs(m_speed_pu),0.01); //RaghTi
	m_theta_el_encoder = remainder (m_abs_theta_mech - m_theta_offset, M_2PI);
	m_theta_el 		   = m_theta_el_encoder;

	switch (m_state){
		case DriveState::Disabled:
			runState_Disabled();
			break;
		case DriveState::Starting:
			runState_Starting();
			break;
		case DriveState::OperationEnabled:
			runState_Operation_Enabled();
			break;
		case DriveState::TestRun:
			runState_Test_Run();
			break;
		default:
			runState_Disabled();
			break;
	}

	// Connection to DA-outputs here:



}



void Drive::runState_Disabled(){
	// Converters disabled; request the Disable-state in Converter Layer.
	Converter1.RequestState(Converter::ConverterState::Disabled);

	// Checking for conditions for Ready_To_Switch_On; typical DC-voltage reached a value required before start-up (parameter in database)

	if (!m_uStatusWord.bit.ready_to_start){ // This bit is only to be cleared at start-up and in fault state
		// Controlling pre-charge relays if chosen



		// Checking if voltage limits are reached
		if(m_conv1.U_dc_avg_V >= m_Udc1_Startup_V){  // Only one converter used .
			// Here the main breaker can be closed in case of motor drives (not usually in case of AFE; then in runState_Starting)

			// The precharge-breaker is opened after a given time and then the ready_to_start bit is set true

			m_uStatusWord.bit.ready_to_start = true; // Should be cleared in fault-state
		}
	}

	m_mode = 1;
}

void Drive::runState_Starting(){
	// Run Flystart for the machine.
	// All variables required to be initialized for Flux- and Torque Control will be initialized
	// Flystart();
	// At time being: Disabled Converters.........
	Converter1.RequestState(Converter::ConverterState::Disabled);

	m_mode = 2;

	// When Flystart is completed the bit m_uStatusWord.bit.operation_enabled is set. Then the Drive state machine goes to
	// the state  Drive::runState_Operation_Enabled(), but still be in the ApplicationState::Switched_On state itself.

	m_uStatusWord.bit.operation_enabled = true;
	if (m_uStatusWord.bit.operation_enabled)
	{ // When Flystart is completed go to DriveState::OperationEnabled
		m_state = DriveState::OperationEnabled;
	  //  Initialize all functions here ??
	}


}


void Drive::runState_Operation_Enabled(){
	// Full Flux- and Torque Control in operation. If the Application state machine still is in Switched_On state, the Torque reference will be zero.
	// When the flux level is reached the Ready_For_Operation _Enable is set. This test should only be made when operation_enable is false.

		if  (m_speed_test > m_speed_max ){
			m_speed_rate_sign=-1.0;
		}
		else if (m_speed_test < -m_speed_max ){
			m_speed_rate_sign=1.0;
		}
		m_speed_test+=m_speed_rate_sign*m_speed_rate;


	Converter1.RequestState(Converter::ConverterState::Enabled);
	//Converter2.RequestState(Converter::ConverterState::Enabled);
	m_mode = 3;

	// Speed and position measurements if encoder is available:


	m_DAC.setInput(DAC::CH_B, m_i.a * hmi.dac.DAC_B_sw_pregain);
	m_DAC.setInput(DAC::CH_D, m_te.ref_input * hmi.dac.DAC_D_sw_pregain);
	// m_DAC.setInput(DAC::CH_A, U_sin_ref_A);


	// Motor model:
	m_te.actual		=FirmWare1.getTorque(true);
	m_te.estimated	=m_i.f*m_i.a;


	// Flux reference calculation or controller:

	m_ua_fw_used =abs(fmin(m_ua_fw, m_ua_max));
	m_psi_sref_used =fmin(m_ua_fw_used/fmax(abs(m_speed_pu),0.1) , 1.0);
	m_psi_sref = m_psi_sref_used;

	// Calculate torque reference and torque limits:

	m_te.ref_used =TorqueRefLimitation(m_te.ref_input,m_te.max,m_te.min); // Torque limits due to currents are dependent of which type of motors


	// Calculate torque reference and torque limits:

	m_ia_ref_pu	= m_te.ref_used / fmax( m_i.f, 0.1);

	// Field weakening Control:
	m_if_ref_pu =  m_psi_sref_used;

	// Current controllers:
	m_ref_conv1.Us_peak_V =  m_UaN * ArmatureCurrentController.Run(m_ia_ref_pu, m_i.a,m_speed_pu*m_i.f, -m_ua_max, m_ua_max);

    // Only converter 1 is used for FB+HB. Note: Use angle for transferring voltage command.
    m_ref_conv1.delta_s_s = m_UfN * FieldCurrentController.Run(m_if_ref_pu, m_i.f, 0.0, 0.0, m_uf_max);

	// Running PWM or hysteresis controller:
	Converter1.SetValues(m_ref_conv1);


	// Check that Flux-level is reached and if so; set DriveStatusBit  ready_for_operation_enable. This is used to set ready_for_operation_enable in Application Layer
	// Can also use a timer increment.....
	m_uStatusWord.bit.ready_for_operation_enable=true;

	// Initialize position sensor ? Apply DC-current in phase A (To be done before ready_for_operation_enable is set.....)
}

void Drive::runState_Test_Run(){
	// Here Pulse-testing or ID-Run are implemented.

	Converter1.RequestState(Converter::ConverterState::TestRun);
	Converter2.RequestState(Converter::ConverterState::TestRun);
	m_mode = 4;
}


const fp32_t Drive::TorqueRefLimitation(const fp32_t torqueref,const fp32_t tmax_extern_lim,const fp32_t tmin_extern_lim ){
	fp32_t teref_return;
	fp32_t IfLim;
	fp32_t IsLim;
	fp32_t T_UL;
	fp32_t T_LL;

	m_te.ref_speed=m_TrefLim.Speed(torqueref,m_speed_pu);
	m_te.max_speed=m_TrefLim.SpeedParam.max;
	m_te.min_speed=m_TrefLim.SpeedParam.min;
	m_uLimitWord.bit.torque_ref_speed=m_TrefLim.SpeedParam.inLimit;

	m_te.ref_power =m_TrefLim.Power(m_te.ref_speed,m_speed_pu,m_p.max,m_p.min);
	m_te.max_power1=m_TrefLim.PowerParam.max;
	m_te.min_power1=m_TrefLim.PowerParam.min;
	m_uLimitWord.bit.torque_ref_power=m_TrefLim.PowerParam.inLimit;

	m_i.limit_converter1 	= m_1_div_IaN*m_conv1.I_limit_A;
	m_i.limit_converter2 	= m_1_div_IfN*m_conv1.I_limit_A;                  // Converter 2 if two converters
	m_i.limit_motor1		= m_DC.CurrentLimitation(m_DC.par.iamax0);        // To be improved later...
	m_i.limit_motor2		= m_DC.FieldCurrentLimitation(m_DC.par.ifmax0);   // To be improved later...
	IsLim =fmin(m_i.limit_converter1,m_i.limit_motor1);
	IfLim =fmin(m_i.limit_converter2,m_i.limit_motor2);

	m_psi_Max  = m_i.f;
	m_te.ref_current =m_TrefLim.Current(m_te.ref_power,IsLim,m_psi_Max);
	m_te.max_Current1=m_TrefLim.CurrentParam.max;
	m_te.min_Current1=m_TrefLim.CurrentParam.min;
	m_uLimitWord.bit.torque_ref_current1=m_TrefLim.CurrentParam.inLimit;

	T_UL=fmin(fmin(m_te.max_speed,m_te.max_power1),m_te.max_Current1);
	T_UL=fmin(T_UL,tmax_extern_lim);
	T_LL=fmax(fmax(m_te.min_speed,m_te.min_power1),m_te.min_Current1);
	T_LL=fmax(T_LL,tmin_extern_lim);

    // Last function in the chain. Shall be able to overrule the current limiter to protect DC-link.
	m_te.ref_udc =m_TrefLim.UdcLink(m_te.ref_current,m_u.dc1,m_speed_pu,T_UL,T_LL);
	m_te.max_udc1=m_TrefLim.UdcParam.max;
	m_te.min_udc1=m_TrefLim.UdcParam.min;
	m_uLimitWord.bit.torque_ref_udc1=m_TrefLim.UdcParam.inLimit;


	// Filtering the used limits:
	m_TrefLim.Filter(m_TrefLim.Tmax_unfiltered,m_TrefLim.Tmin_unfiltered);
	m_te.max_used=m_TrefLim.Tmax_k;
	m_te.min_used=m_TrefLim.Tmin_k;

	//teref_return= fmax( fmin(m_te.ref_udc, m_te.max_used), m_te.min_used);
	teref_return= fmax( fmin(torqueref, m_te.max_used), m_te.min_used);

	return teref_return;
}

void Drive::getFaultAndWarnings(){
    // This routine has to be modified if only one converter is in use.
	m_Converter1_Faults		= Converter1.GetFaults();
	m_Converter2_Faults		= Converter2.GetFaults();
	m_Converter1_Warnings   = Converter1.GetWarnings();
	m_Converter2_Warnings	= Converter2.GetWarnings();

	if (m_Converter1_Faults.all != 0){
			m_uFaultWord.bit.converter_1=true;
		}

	if (m_Converter1_Warnings.all == 0){
		m_uWarningWord.bit.converter_1=false;
	}
	else{
		m_uWarningWord.bit.converter_1=true;
	}

	/*if (m_Converter2_Faults.all != 0){
		m_uFaultWord.bit.converter_2=true;
	}

	if (m_Converter2_Warnings.all == 0){
		m_uWarningWord.bit.converter_2=false;
	}
	else{
		m_uWarningWord.bit.converter_2=true;
	}
	*/
	m_uFaultWord.bit.converter_2	=false;
	m_uWarningWord.bit.converter_2	=false;

	// Here one can decide which converters to used :
	// For DC drive we only consider Converter  while Converter 2 is not in use.

	m_uFaultWord.bit.Watch_Dog_conv_1=m_Converter1_Faults.bit.Watchdog_is_expired;
	m_uFaultWord.bit.Watch_Dog_conv_2=false;


}




