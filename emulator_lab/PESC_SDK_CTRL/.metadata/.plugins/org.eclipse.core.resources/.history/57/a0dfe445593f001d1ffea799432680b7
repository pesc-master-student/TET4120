/************************************************************************************

File Name:      Emulator.cpp
Description:    Implementation code. Further details explained in Emulator.hpp

*************************************************************************************/

#include "ConfigParameters.hpp"
extern ConfigParameters Parameters;

#include "Emulator.hpp"


void Emulator::initialize(void){

	emu_dc_Initialize(&m_EmulatorIP, 0);

	Parameters.FW1.Emulator.MACHINE_ID = (e_DRIVE_ID) emu_dc_motor_id_read(&m_EmulatorIP);

	// initialize all static parameters
	//----------------------------------

	Tstep 				= Parameters.FW1.Emulator.Tstep;
	polepairs 			= Parameters.Drive1.MotorData.polepairs;  // Should/could be read directly from the the drive data....
	Uabasis				= Parameters.Drive1.MotorData.UaN_V-Parameters.Drive1.MotorData.Ra_Ohm*Parameters.Drive1.MotorData.IaN_A ;
	M.ra 				= Parameters.Drive1.MotorData.Ra_Ohm* Parameters.Drive1.MotorData.IaN_A/Uabasis;
	M.la   				= Parameters.Drive1.MotorData.La_H*Parameters.Drive1.MotorData.IaN_A/Uabasis;			// Ta=la/ra  [s]
	M.Tf				= Parameters.Drive1.MotorData.Tf;
	M.Tm				= Parameters.FW1.Emulator.Tm;
	M.Nn			    = Parameters.Drive1.MotorData.Nn_rpm;
	M.kn				= Parameters.FW1.Emulator.kn;

	M.UfN				= Parameters.Drive1.MotorData.UfN_V;
	Udc1_V              = Parameters.FW1.Emulator.Udc1_V;
	T_basis				= Uabasis * Parameters.Drive1.MotorData.IaN_A /( Parameters.Drive1.MotorData.Nn_rpm * M_PI / 30.0 );
	one_div_Tbasis		= 1.0/T_basis;
	N_basis_rpm 		= M.Nn;

	magnetize_topology  = 0;      // FB converter , i.e. converter 2 used
	if (Parameters.Converter1.Converter_Topology==2){
		magnetize_topology  = 1;  // HF converter, i.e. leg c i converter 1 used
	}

	A_bit_per_pu_conv1 = Parameters.Converter1.ADC.bit_per_A_a * Parameters.Drive1.MotorData.IaN_A;
	V_bit_per_pu_conv1 = Parameters.Converter1.ADC.bit_per_V * Parameters.Drive1.MotorData.Uabasis_V;

	if (magnetize_topology ==0){
		  A_bit_per_pu_conv2 = Parameters.Converter2.ADC.bit_per_A_a * Parameters.Drive1.MotorData.IfN_A;
		  V_bit_per_pu_conv2 = Parameters.Converter2.ADC.bit_per_V * Parameters.Drive1.MotorData.UfN_V;
		  Udc2_V              = Parameters.FW1.Emulator.Udc2_V;
	}
	else {
		  A_bit_per_pu_conv2 = Parameters.Converter1.ADC.bit_per_A_c * Parameters.Drive1.MotorData.IfN_A;
		  V_bit_per_pu_conv2 = Parameters.Converter1.ADC.bit_per_V * Parameters.Drive1.MotorData.UfN_V;
		  Udc2_V =Udc1_V;
	}

	udc1				= Udc1_V / Uabasis;
	udc2				= Udc2_V / M.UfN;

	PU.Ts_div_la_pu = Tstep / M.la;
	PU.Ts_div_Tf_pu = Tstep / M.Tf;
	PU.Ts_div_Tm_pu = Tstep / M.Tm;
	k_fNmech_Tstep	 = pow(2,64-28) * M.Nn * Tstep / 60;


	// -----------------   TESTING FINISHED  ------------------------
	emu_dc_polepairs_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * polepairs) );
	emu_dc_ra_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * M.ra) );
	emu_dc_ts_la_write(&m_EmulatorIP, static_cast<int32_t>(PU_BASE_SCALING * PU.Ts_div_la_pu) );
	emu_dc_ts_tf_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * PU.Ts_div_Tf_pu) );
	emu_dc_ts_tm_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * PU.Ts_div_Tm_pu) );
	emu_dc_kn_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * M.kn) );
	emu_dc_vdc1_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * udc1) );
	emu_dc_vdc2_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * udc2) );

	emu_dc_current_pu_bit_conv1_write(&m_EmulatorIP, static_cast<uint32_t>(A_bit_per_pu_conv1) );
	emu_dc_voltage_pu_bit_conv1_write(&m_EmulatorIP, static_cast<uint32_t>(V_bit_per_pu_conv1) );
	emu_dc_current_pu_bit_conv2_write(&m_EmulatorIP, static_cast<uint32_t>(A_bit_per_pu_conv2) );
	emu_dc_voltage_pu_bit_conv2_write(&m_EmulatorIP, static_cast<uint32_t>(V_bit_per_pu_conv2) );


	// -----------------   TESTING IN PROGRESS  ------------------------
	emu_dc_k_fnmechtstep_write(&m_EmulatorIP, static_cast<uint32_t>(k_fNmech_Tstep) );
	emu_dc_magnetization_4q_1q_write(&m_EmulatorIP, static_cast<uint32_t>(magnetize_topology));

}


void Emulator::setLoadTorque(const fp32_t& LoadTorque_Nm){

	fp32_t tpuload;
	T_L_Nm =LoadTorque_Nm;
	tpuload = LoadTorque_Nm*one_div_Tbasis;
	emu_dc_tl_write(&m_EmulatorIP, static_cast<int32_t>(PU_BASE_SCALING * tpuload) );
}

void Emulator::setValues(void){

		// -----------------   TESTING FINISHED  ------------------------
		emu_dc_vdc1_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * udc1) );
		emu_dc_vdc2_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * udc2) );
		//emu_dc_tl_write(&m_EmulatorIP, static_cast<int32_t>(PU_BASE_SCALING * hmi.emulator.t_L) );
		Udc1_V = udc1 * Uabasis;
		Udc2_V = udc2 * M.UfN;


		/*  IN CASE YOU WANT TO TUNE THE MACHINE INTO ALTERNATIVE CHARACTERISTICS
		emu_dc_polepairs_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.polepairs) );
		emu_dc_ra_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.r_a) );
		emu_dc_kn_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.k_n) );
		emu_dc_ts_la_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.ts_la) );
		emu_dc_ts_tm_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.ts_tm) );
		emu_dc_ts_tf_write(&m_EmulatorIP, static_cast<uint32_t>(PU_BASE_SCALING * hmi.emulator.ts_tf) );

		emu_dc_current_pu_bit_conv1_write(&m_EmulatorIP, static_cast<uint32_t>(A_bit_per_pu_conv1) );
		emu_dc_voltage_pu_bit_conv1_write(&m_EmulatorIP, static_cast<uint32_t>(V_bit_per_pu_conv1) );
		emu_dc_current_pu_bit_conv2_write(&m_EmulatorIP, static_cast<uint32_t>(A_bit_per_pu_conv2) );
		emu_dc_voltage_pu_bit_conv2_write(&m_EmulatorIP, static_cast<uint32_t>(V_bit_per_pu_conv2) );
		*/

		// -----------------   UNDER TESTING  -----------------------
		//emu_dc_k_fntstep_write(&m_EmulatorIP, static_cast<uint32_t>(2047 / hmi.emulator.wn_ts) );

		// -----------------   NOT TESTED  ------------------------
}

void Emulator::getValues(void){

		// -----------------   FINAL DATA TYPE TESTED  ------------------------
		AXI.Udc_1_axi = emu_dc_vdc1_read(&m_EmulatorIP);
		AXI.Udc_2_axi = emu_dc_vdc2_read(&m_EmulatorIP);
		PU.Udc_1_pu = static_cast<fp32_t> (AXI.Udc_1_axi) / PU_BASE_SCALING;
		PU.Udc_2_pu = static_cast<fp32_t> (AXI.Udc_2_axi) / PU_BASE_SCALING;
		AXI.FieldConverter_Topology = emu_dc_magnetization_4q_1q_read(&m_EmulatorIP);

		AXI.polepairs_axi = emu_dc_polepairs_read(&m_EmulatorIP);
		polepairs = static_cast<int32_t> (AXI.polepairs_axi) / PU_BASE_SCALING;
		AXI.T_L_axi = emu_dc_tl_read(&m_EmulatorIP);
		PU.T_L_pu = static_cast<fp32_t> (AXI.T_L_axi) / PU_BASE_SCALING;
		AXI.ra_axi = emu_dc_ra_read(&m_EmulatorIP);
		PU.ra_pu = static_cast<fp32_t> (AXI.ra_axi) / PU_BASE_SCALING;
		AXI.kn_axi = emu_dc_kn_read(&m_EmulatorIP);
		PU.kn_pu = static_cast<fp32_t> (AXI.kn_axi) / PU_BASE_SCALING;

		AXI.Ts_div_Tm_axi = emu_dc_ts_tm_read(&m_EmulatorIP);
		PU.Ts_div_Tm_pu = static_cast<fp32_t> (AXI.Ts_div_Tm_axi) / PU_BASE_SCALING;
		AXI.Ts_div_la_axi = emu_dc_ts_la_read(&m_EmulatorIP);
		PU.Ts_div_la_pu = static_cast<fp32_t> (AXI.Ts_div_la_axi) / PU_BASE_SCALING;
		AXI.Ts_div_Tf_axi = emu_dc_ts_tf_read(&m_EmulatorIP);
		PU.Ts_div_Tf_pu = static_cast<fp32_t> (AXI.Ts_div_Tf_axi) / PU_BASE_SCALING;

		AXI.I_a_axi = emu_dc_ia_read(&m_EmulatorIP);
		PU.I_a_pu = static_cast<fp32_t> (AXI.I_a_axi) / PU_BASE_SCALING;


		AXI.T_e_axi = emu_dc_te_read(&m_EmulatorIP);
		AXI.I_f_axi = emu_dc_if_x0_read(&m_EmulatorIP);


		PU.T_e_pu = static_cast<fp32_t> (AXI.T_e_axi) / PU_BASE_SCALING;
		PU.I_f_pu = static_cast<fp32_t> (AXI.I_f_axi) / PU_BASE_SCALING;

		AXI.speed_axi = emu_dc_speed_read(&m_EmulatorIP);
		PU.speed_pu = static_cast<fp32_t> (AXI.speed_axi) / PU_BASE_SCALING;

		AXI.theta_el_axi = emu_dc_theta_el_read(&m_EmulatorIP);
		PU.theta_el = static_cast<fp32_t> (AXI.theta_el_axi) / THETA_BASE_SCALING;
		AXI.theta_mech_axi = emu_dc_theta_mech_read(&m_EmulatorIP);
		PU.theta_mech = static_cast<fp32_t> (AXI.theta_mech_axi) / THETA_BASE_SCALING;
		AXI.k_fN_Tstep_axi = emu_dc_k_fnmechtstep_read(&m_EmulatorIP);


		// -----------------   NOT TESTED  --------------------------

		// -----------------   SECTION  3   ------------------------
		// These are read-back registers placed outside the emulator in Vivado
		// for monitoring emulator input/output and multiplexer output
		for(int i=0; i < 8; i++)
			output[i] = REGISTER_ARRAY(XPAR_REGISTER_EMU_OUT_BASEADDR, i);

		for(int i=0; i < 8; i++)
			mux[i] = REGISTER_ARRAY(XPAR_REGISTER_MUX_OUT_BASEADDR, i);

}


