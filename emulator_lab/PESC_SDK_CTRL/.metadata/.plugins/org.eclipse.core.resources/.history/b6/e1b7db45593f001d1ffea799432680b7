/************************************************************************************

File Name:      Converter_2L_3ph.cpp
Description:    Implementation code. Further details explained in Converter_2L_3ph.hpp

*************************************************************************************/



#include "Converter.hpp"


extern fp32_t Tsamp;
int counter = 0;


const bool  Converter::resetFaultWord(void){
// To be improved
	  m_uFaultWord.all = 0x0000;
	  m_uStatusWord.all = 0x0000;

	  b_Reset_Fault_Status=true;

	  return b_Reset_Fault_Status;
}



void Converter::getFWaddress(unsigned int converter_ID){

	  m_PWM.getFWaddress(converter_ID);
	  m_GD.getFWaddress(converter_ID);
	  m_hysteresis_ctrl.getFWAddress(converter_ID);

	  m_IU.getFWaddress(converter_ID);
	  m_Tripp.getFWaddress(converter_ID);

	  m_MA_Filter.getFWaddress(converter_ID, Filter::MOVING_AVERAGE);  // MA: Instant = 0+2 of filter_block
	  m_LP_Filter.getFWaddress(converter_ID, Filter::LOW_PASS);
}


void Converter::initialize(unsigned int converter_ID){

	  m_Converter_ID = converter_ID;
	  m_uFaultWord.all = 0x0000;
	  m_uStatusWord.all = 0x0000;

	  if(converter_ID == 1){
	  		m_Ia_Warning_A  	= Parameters.Converter1.Warning.Ia_A;
	  		m_Ib_Warning_A  	= Parameters.Converter1.Warning.Ib_A;
	  		m_Ic_Warning_A  	= Parameters.Converter1.Warning.Ic_A;
	  		m_Udc_max_Warning_V = Parameters.Converter1.Warning.Udc_max_V;
	  		m_Udc_min_Warning_V = Parameters.Converter1.Warning.Udc_min_V;
	  		m_Ia_Fault_A  		= Parameters.Converter1.Fault.Ia_A;
	  		m_Ib_Fault_A  		= Parameters.Converter1.Fault.Ib_A;
	  		m_Ic_Fault_A  		= Parameters.Converter1.Fault.Ic_A;
	  		m_Udc_min_Fault_V  	= Parameters.Converter1.Fault.Udc_min_V;
	  		m_Ia_Limit_A		= Parameters.Converter1.Limit.Ia_A;
	  		m_Ib_Limit_A		= Parameters.Converter1.Limit.Ib_A;
	  		m_Ic_Limit_A		= Parameters.Converter1.Limit.Ic_A;
	  		m_Converter_Topology= Parameters.Converter1.Converter_Topology;
	  		m_hysteresis_ctrl.initialize( Parameters.Converter1.ADC.bit_per_A_a);
	  	}
	  	else{
	  		m_Ia_Warning_A  	= Parameters.Converter2.Warning.Ia_A;
	  		m_Ib_Warning_A  	= Parameters.Converter2.Warning.Ib_A;
	  		m_Ic_Warning_A  	= Parameters.Converter2.Warning.Ic_A;
	  		m_Udc_max_Warning_V = Parameters.Converter2.Warning.Udc_max_V;
	  		m_Udc_min_Warning_V = Parameters.Converter2.Warning.Udc_min_V;
	  		m_Ia_Fault_A  		= Parameters.Converter2.Fault.Ia_A;
	  		m_Ib_Fault_A  		= Parameters.Converter2.Fault.Ib_A;
	  		m_Ic_Fault_A  		= Parameters.Converter2.Fault.Ic_A;
	  		m_Udc_min_Fault_V  	= Parameters.Converter2.Fault.Udc_min_V;
	  		m_Ia_Limit_A		= Parameters.Converter2.Limit.Ia_A;
	  		m_Ib_Limit_A		= Parameters.Converter2.Limit.Ib_A;
	  		m_Ic_Limit_A		= Parameters.Converter2.Limit.Ic_A;
	  		m_Converter_Topology= Parameters.Converter2.Converter_Topology;
	  		m_hysteresis_ctrl.initialize( Parameters.Converter2.ADC.bit_per_A_a);
	  	}

	  m_PWM.initialize(converter_ID);
	  m_GD.initialize();
	  m_hysteresis_ctrl.initialize(49.128); // ????

	  m_LP_Filter.initialize(converter_ID, Filter::LOW_PASS, Tsamp);
	  m_IU.initialize(converter_ID, m_MA_Filter.initialize(converter_ID, Filter::MOVING_AVERAGE, Tsamp)); // MA: Instant = 2 of filter_block
	  m_Tripp.initialize(converter_ID, m_IU.bit_per_Aa, m_IU.bit_per_Ab, m_IU.bit_per_Ac, m_IU.bit_per_V);


}

const uint16_t Converter::getStatus(unsigned int converter_ID){ // Some Bits should not be read if the Process Emulator is used instead of real Converter

	  uint32_t help;
	  uint16_t ConverterFault;
	  fp32_t   max_abs_current;


	  m_GD_status		= m_GD.getStatusRegister();
	  m_Tripp_status 	= m_Tripp.getFlipFlops();

	  if(hmi.fsm.clearStatusWord){
		  m_uStatusWord.all = 0x0000;
		  m_uFaultWord.all = 0x0000;
	  }

	  // Status:
	  m_uStatusWord.all= m_SetBit.RunSetClear(m_GD_status, 8,m_uStatusWord.all, 0);    // GD_Bit  8: DRIVER_OK                StatusWord Bit  0: Gate_Driver_ready
	  m_uStatusWord.all= m_SetBit.RunSetClear(m_GD_status, 24,m_uStatusWord.all, 1);   // GD_Bit 24: ENABLED                  StatusWord Bit  1: Gate_Driver_is_enabled
	  m_uStatusWord.all= m_SetBit.RunSetClear(m_GD_status, 28,m_uStatusWord.all, 2);   // GD_Bit 28: Hardware_Interlock       StatusWord Bit  2: Hardware_Interlock
	  m_uStatusWord.all= m_SetBit.DecodeStatus(m_GD_status, m_uStatusWord.all);        // GD_Bit first 4 bits.                Coding of sources of Status.
	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	       //    Value:   0                       StatusWord Bit  4: OK_Ready
	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	   //    Value:   1                       StatusWord Bit  3: Main_contactor_open
	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	   //    Value:   2                       StatusWord Bit  5: Signal_2
	  	  	  	  	  	  	  													       //    Value:   4                       StatusWord Bit  6: Signal_4
	  	  	  	  	  	  	  													       //    Value:   6                       StatusWord Bit  7: Signal_6

	  // Faults:
	  m_uFaultWord.all = m_SetBit.RunSet(m_GD_status, 26, m_uFaultWord.all, 0);        // GD_Bit 26: WATCHDOG_EXPIRED          FaultWord Bit   0: Watchdog_is_expired
	  m_uFaultWord.all = m_SetBit.RunSet(m_GD_status, 31, m_uFaultWord.all, 1);        // GD_Bit 31: Extern_WATCHDOG_EXPIRED   FaultWord Bit   1: extern_Watchdog_expired
	  m_uFaultWord.all = m_SetBit.RunSet(m_Tripp_status, 3, m_uFaultWord.all, 12);     // GD_Bit 30: Over voltage FW           FaultWord Bit  12: DC_link_overvoltage_FW
	  help= m_Tripp_status & 0x7;
	  if(help != 0)
	  {
		  help = 1; // At least one of the 3 currents are in limit
	  }
	  m_uFaultWord.all = m_SetBit.RunSet(help, 0, m_uFaultWord.all, 10); 		       // GD_Bit 29: Current trip FW           FaultWord Bit   10: overcurrent_FW
	  m_uFaultWord.all = m_SetBit.DecodeFault(m_GD_status, m_uFaultWord.all);          // GD_Bit first 4 bits.                 Coding of sources of Fault.
  	  	  	  	  	  	       	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:   3                        FaultWord Bit 11: DC_link_overvoltage_GD
					       	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:   6                        FaultWord Bit 13: overtemperature_GD
	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	   //    Value:   7                        FaultWord Bit  9: overcurrent_GD
					       	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:   8                        FaultWord Bit  7: phase_C_lower
  	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:   9                        FaultWord Bit  5: phase_B_lower
  	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:  10                        FaultWord Bit  3: phase_A_lower
	  	  	  	  	  	  	  	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:  11                        FaultWord Bit  8: Brake_Chopper
  	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:  12                        FaultWord Bit  6: phase_C_upper
   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:  13                        FaultWord Bit  4: phase_B_upper
	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   	   //    Value:  14                        FaultWord Bit  2: phase_A_upper

	  // NEW 2021-04-08  ROY
	  if(m_Converter_Topology == 0){ // 3 phase converter
		  max_abs_current=fmax(fmax(abs(m_IU.Ia_MA_A),abs(m_IU.Ib_MA_A)),abs(m_IU.Ic_MA_A));
		  m_uWarningWord.bit.overcurrent  = m_SetBit.Warning(max_abs_current,m_Ia_Warning_A);
		  m_uFaultWord.bit.overcurrent_SW = m_SetBit.Fault(max_abs_current,m_Ia_Fault_A,m_uFaultWord.bit.overcurrent_SW);
	  }
	  else if (m_Converter_Topology == 1) { // Full-bridge phase a and b FB . Typical Field winding
		  max_abs_current=abs(m_IU.Ia_MA_A);
		  m_uWarningWord.bit.overcurrent  = m_SetBit.Warning(max_abs_current,m_Ia_Warning_A);
		  m_uFaultWord.bit.overcurrent_SW = m_SetBit.Fault(max_abs_current,m_Ia_Fault_A,m_uFaultWord.bit.overcurrent_SW);
	 }
	  else {  // Full-bridge phase a and b FB for armature winding and phase c for Field winding HB (Half-bridge)
		  max_abs_current=abs(m_IU.Ia_MA_A);
		  m_uWarningWord.bit.overcurrent  = m_SetBit.Warning(max_abs_current,m_Ia_Warning_A);
		  m_uFaultWord.bit.overcurrent_SW = m_SetBit.Fault(max_abs_current,m_Ia_Fault_A,m_uFaultWord.bit.overcurrent_SW);
		  max_abs_current=abs(m_IU.Ic_MA_A);
		  m_uWarningWord.bit.overcurrent  = m_SetBit.Warning(max_abs_current,m_Ic_Warning_A);
		  m_uFaultWord.bit.overcurrent_SW = m_SetBit.Fault(max_abs_current,m_Ic_Fault_A,m_uFaultWord.bit.overcurrent_SW);
	  }

	  m_uWarningWord.bit.DC_link_overvoltage   = m_SetBit.Warning(m_IU.Udc_MA_V,m_Udc_max_Warning_V);
	  if (m_state != ConverterState::Disabled)
	  {  // Minus signs due to minimum test, i.e. less than...
	     m_uFaultWord.bit.DC_link_undervoltage_SW = m_SetBit.Fault( -m_IU.Udc_MA_V, -m_Udc_min_Fault_V, m_uFaultWord.bit.DC_link_undervoltage_SW);
	  }



	  m_GD.reload_internal_wtchdog(hmi.gd.wtchdg_val);                                 // Have to reload the timer AFTER we have read DRIVER_STATUS_REG !!!!!
	                                                                                   // If not we miss the information about Watch_dog_expired !!


	  // ----------- FIRMWARE OC/OV TRIPPING  ---------------
	  if(hmi.trip.clear){
		  counter++;
		  m_Tripp.clearFaults();
		  if (counter == 2){
			  counter = 0;
			  hmi.trip.clear = false;
		  }
	  }
	 /* if(hmi.trip.run_trim){
		  m_Tripp.setCurrentLimit(hmi.trip.channel, hmi.trip.ampLim);
		  m_Tripp.setDCLinkVoltLimit(hmi.trip.dcLim);
		  hmi.trip.run_trim = false;
	  } */

	  m_Tripp.getTripLimits();

	  if (m_uFaultWord.all == 0){
		  ConverterFault=false;
	  }
	  else{
		  ConverterFault=true;
		  m_GD.disable();
	  }


	  	 /*
		// ----------- PWM  ---------------
		// m_PWM.setTriangleHysteresis(hmi.pwm.margin);
		m_PWM.getCarrierWave();
		if(hmi.pwm.mode)
			m_PWM.runABC(hmi.emulator.volt_ref_Ua, -hmi.emulator.volt_ref_Ua, 0);
		else{
			//m_Udc_V = m_IU.Udc_MA_V;

			m_U_peak_max_V = m_PWM.runSpaceVector(m_Us_peak_V,m_delta_s_s, m_Udc_V );
		}
		*/

		// Enable Drive:
		//m_GD.enable(); //   Her ???? Roy

		// Select Hysteresis Current controller or PWM
		m_GD.setDriverSource(hmi.gd.src);

		// Get values for check:
		m_GD.getGlobalEnable();
		m_GD.getHWHexStatusCode();
		m_GD.getStatusRegister();
		m_GD.get_internal_wtchdog_value();
		m_GD.get_internal_wtchdog_status();
		m_GD.get_disable_flags();
		m_GD.getDriverConfigRegister();
		m_GD.switching_frequency_measurement();



	  return ConverterFault;


}

void Converter::SetValues(ValueConvRef References){

	m_Us_peak_V			=	References.Us_peak_V;
	m_delta_s_s			=	References.delta_s_s;
	m_I_aref_A			=	References.I_aref_A;
	m_I_bref_A			=	References.I_bref_A;
	m_I_cref_A			=	References.I_cref_A;
	m_HysteresisWidth_A	=	References.HysteresisWidth_A;
}

const uConverterFaultWord Converter::GetFaults(){
	return m_uFaultWord;
}

const uConverterWarningWord Converter::GetWarnings(){
	return m_uWarningWord;
}

const ValueMeasure Converter::getMeasurements(){

	  // ----Sampled Measurements used for Control ---  From Registers ------- SCALE INTO SI-UNITS  ---------------
	//  m_IU.fine_tune(hmi.SI.channel, hmi.SI.fineScale);
	  m_IU.getScaledSamples();

	  m_measured_values.I_sa_A = m_IU.Ia_LP_A;
	  m_measured_values.I_sb_A = m_IU.Ib_LP_A;
	  m_measured_values.I_sc_A = m_IU.Ic_LP_A;
	  m_measured_values.U_dc_V = m_IU.Udc_LP_V;
 
	  m_measured_values.I_sa_avg_A = m_IU.Ia_MA_A;
	  m_measured_values.I_sb_avg_A = m_IU.Ib_MA_A;
	  m_measured_values.I_sc_avg_A = m_IU.Ic_MA_A;
	  m_measured_values.U_dc_avg_V = m_IU.Udc_MA_V;
	  m_measured_values.U_a0_avg_V = m_IU.Ua0_MA_V;
	  m_measured_values.U_b0_avg_V = m_IU.Ub0_MA_V;
	  m_measured_values.U_c0_avg_V = m_IU.Uc0_MA_V;

	  m_measured_values.U_peak_max_V = m_U_peak_max_V;

	  m_measured_values.I_limit_A    = CurrentLimitation(0.0);

/*
	//----- For tuning purposes only -------
	// ======================================

	// ----------- LOW-PASS FILTER  ---------------
	  m_LP_Filter.tuneLPfilterCutFreq(hmi.filter.LP_usecTimeConst);
	  m_LP_Filter.getInputSamples();
	  m_LP_Filter.getOutSamples();


	  // ----------- MOVING AVERAGE FILTER  ---------------
	  if(hmi.filter.runMAsetScalingType){
	  MA_filter_gain =  m_MA_Filter.tuneMAfilterScaleMode(hmi.filter.gainMODE, Tsamp);
		  hmi.filter.runMAsetScalingType = false;
	  }

	  m_MA_Filter.getInputSamples();
	  m_MA_Filter.getOutSamples();
	  m_MA_Filter.getShiftRegisters();
	  m_MA_Filter.getMultiplyRegisters();

*/
	  return m_measured_values;
}


void Converter::RequestState(enum ConverterState converter_status){
	// Here conditions for changing the state has to be considered and m_state given the proper value

	switch (converter_status){
			case ConverterState::Disabled:
				m_state = ConverterState::Disabled;
				break;
			case ConverterState::Enabled:
				m_state = ConverterState::Enabled;
				break;
			case ConverterState::TestRun:
				m_state = ConverterState::TestRun;
				break;
			default:
				m_state = ConverterState::Disabled;
				break;
		}

}


void Converter::run(){

	switch (m_state){
		case ConverterState::Disabled:
			runState_Disabled();
			break;
		case ConverterState::Enabled:
			runState_Enabled();
			break;
		case ConverterState::TestRun:
			runState_Test_Run();
			break;
		default:
			runState_Disabled();
			break;
	}


}



// Name-RunState_definitions
// This file contains the PWM i.e. fast routine
// Key modules
//  3. Transformations
//  4. UI / CIN model for rotor flux calculations
//  5. Current Regulators d-q
//  6. Dead time correction function.
//  7. SPWM function call

void Converter::runState_Disabled(){
	 m_GD.disable();
	 // Initialize something ? Hysteresis Controller, PWM ?

}

void Converter::runState_Enabled(){



	  // ----------- HYSTERESIS CURRENT CONTROLLER  ---------------
	/*	  m_hysteresis_ctrl.setCurrentReference(0, m_I_aref_A);
		  m_hysteresis_ctrl.setCurrentReference(1, m_I_bref_A);
		  m_hysteresis_ctrl.setCurrentReference(2, m_I_cref_A);
		  m_hysteresis_ctrl.setToleranceBand(m_HysteresisWidth_A);

		  m_hysteresis_ctrl.getToleranceBand();
		  m_hysteresis_ctrl.getCurrentReferences();
		  m_hysteresis_ctrl.getOutput();
      */

	 	//m_PWM.PWM_2L_2Ph_Unipolar(hmi.emulator.volt_ref_Ua, hmi.emulator.volt_ref_Uf);

	if(m_Converter_Topology == 0){
		m_U_peak_max_V = m_PWM.runSpaceVector(m_Us_peak_V, m_delta_s_s, m_IU.Udc_MA_V );
	}
	else if (m_Converter_Topology==1){
		m_U_peak_max_V = m_PWM.Unipolar(m_Us_peak_V, m_IU.Udc_MA_V );
	}
	else{ // m_Converter_Topology==2: FB leg a and b  HB leg c
		m_U_peak_max_V = m_PWM.UnipolarFBandHB(m_Us_peak_V, m_delta_s_s, m_IU.Udc_MA_V );
		//m_U_peak_max_V = m_PWM.UnipolarFBandHB(hmi.pwm.amplitude_VOLTAGE_1, m_delta_s_s, m_IU.Udc_MA_V );

	}


	/*
	angle_sinus++;
	if(angle_sinus >= 6.28)
		angle_sinus = 0;

		//m_U_peak_max_V = m_PWM.runSpaceVector(hmi.pwm.amplitude_VOLTAGE, angle_sinus, m_IU.Udc_MA_V );
		//m_U_peak_max_V = m_PWM.Unipolar(hmi.pwm.amplitude_VOLTAGE, m_IU.Udc_MA_V );
	    // m_Converter_Topology==2: FB leg a and b  HB leg c
		m_U_peak_max_V = m_PWM.UnipolarFBandHB(hmi.pwm.amplitude_VOLTAGE_1, hmi.pwm.amplitude_VOLTAGE_2, m_IU.Udc_MA_V );
*/
		// Enable Drive:
		m_GD.enable();

		// Select Hysteresis Current controller or PWM
		m_GD.setDriverSource(hmi.gd.src);

	/*	// Get values for check:
		m_GD.getGlobalEnable();
		m_GD.getHWHexStatusCode();
		m_GD.getStatusRegister();
		m_GD.get_internal_wtchdog_value();
		m_GD.get_internal_wtchdog_status();
		m_GD.get_disable_flags();
		m_GD.getDriverConfigRegister();
		m_GD.switching_frequency_measurement();
     */
		// Calculate Current limits for the converter: To be read by the Drive Layer
}

void Converter::runState_Test_Run(){
	// Disabled at time being...
	 m_GD.disable();
}

const fp32_t Converter::CurrentLimitation(const fp32_t Iamplitude){ // Can be more inputs; Temperature, Frequency, etc....Dynamic model
	fp32_t I_lim_return_A;

	I_lim_return_A=m_Ia_Limit_A;

	return I_lim_return_A;
}

