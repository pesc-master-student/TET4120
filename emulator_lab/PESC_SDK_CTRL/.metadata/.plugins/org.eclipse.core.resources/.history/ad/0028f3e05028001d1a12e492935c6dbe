/*************************************************************************************

File Name:      TorqueLimiters.cpp
Description:    Implementation of torque limiter functions

*************************************************************************************/

#include "TorqueLimiters.hpp"
extern fp32_t Tsamp;

void TorqueLimiter::initialize(const fp32_t InverseUdcbasis){

SpeedParam.Speed_max=   Parameters.Drive1.DriveData.Speed_max;
SpeedParam.Speed_min=	Parameters.Drive1.DriveData.Speed_min;
SpeedParam.dT_dSpeed=	Parameters.Drive1.DriveData.dT_dSpeed;
SpeedParam.Te_maxSpeed= Parameters.Drive1.DriveData.Te_max;
SpeedParam.Te_minSpeed= Parameters.Drive1.DriveData.Te_min;

UdcParam.Udc_max= 		InverseUdcbasis*Parameters.Drive1.DriveData.Udc_max_V;  // Convert to pu
UdcParam.Udc_min= 		InverseUdcbasis*Parameters.Drive1.DriveData.Udc_min_V;  // Convert to pu
UdcParam.dT_dUdc= 		Parameters.Drive1.DriveData.dT_dUdc;
UdcParam.Te_maxUdc= 	Parameters.Drive1.DriveData.Te_maxUdc;
UdcParam.Te_minUdc= 	Parameters.Drive1.DriveData.Te_minUdc;

PowerParam.P_max=		Parameters.Drive1.DriveData.P_max;
PowerParam.P_min=		Parameters.Drive1.DriveData.P_min;

m_Tlim_increase	= Tsamp/fmax(Parameters.Drive1.DriveData.Tlim_slope_filter,0.001);
FilterSetValue(SpeedParam.Te_maxSpeed,SpeedParam.Te_minSpeed);


}

const fp32_t TorqueLimiter::Speed(const fp32_t torqueref,const fp32_t speed){

	fp32_t torqueref_return;

	SpeedParam.max=fmin(SpeedParam.Te_maxSpeed,-SpeedParam.dT_dSpeed*(speed-SpeedParam.Speed_max));
	SpeedParam.min=fmax(SpeedParam.Te_minSpeed,-SpeedParam.dT_dSpeed*(speed-SpeedParam.Speed_min));
	SpeedParam.max=fmax(SpeedParam.max,SpeedParam.Te_minSpeed);
	SpeedParam.min=fmin(SpeedParam.min,SpeedParam.Te_maxSpeed);

	if ((torqueref >= SpeedParam.max)|(torqueref <= SpeedParam.min)){
		SpeedParam.inLimit=1;
	}
	else{
		SpeedParam.inLimit=0;
	}

	torqueref_return=fmax(fmin(torqueref,SpeedParam.max),SpeedParam.min);

	return torqueref_return;
}

const fp32_t TorqueLimiter::UdcLink(const fp32_t torqueref,const fp32_t Udc, const fp32_t speed,const fp32_t Tlim_max,const fp32_t Tlim_min){

	fp32_t torqueref_return;



	if (speed >= 0.0){

		UdcParam.max=fmin(SpeedParam.Te_maxSpeed,UdcParam.dT_dUdc*fmax((Udc-UdcParam.Udc_min),0.0)+UdcParam.Te_minUdc);
		UdcParam.min=fmax(SpeedParam.Te_minSpeed,UdcParam.dT_dUdc*fmin((Udc-UdcParam.Udc_max),0.0)+UdcParam.Te_maxUdc);

		Tmin_unfiltered=fmax(UdcParam.min,Tlim_min);
		Tmax_unfiltered=fmax(fmin(UdcParam.max,Tlim_max),Tmin_unfiltered);

		torqueref_return=fmin(torqueref,UdcParam.max);
		torqueref_return=fmax(torqueref_return,UdcParam.min);  // Overrules max limit to avoid over-voltage during braking

	}
	else{ // speed < 0

		UdcParam.max=fmin(SpeedParam.Te_maxSpeed,-UdcParam.dT_dUdc*fmin((Udc-UdcParam.Udc_max),0.0)-UdcParam.Te_maxUdc);
		UdcParam.min=fmax(SpeedParam.Te_minSpeed,-UdcParam.dT_dUdc*fmax((Udc-UdcParam.Udc_min),0.0)-UdcParam.Te_minUdc);

		Tmax_unfiltered=fmin(UdcParam.max,Tlim_max);
		Tmin_unfiltered=fmin(fmax(UdcParam.min,Tlim_min),Tmax_unfiltered);

		torqueref_return=fmax(torqueref,UdcParam.min);
		torqueref_return=fmin(torqueref_return,UdcParam.max);  // Overrules min limit to avoid over-voltage during braking
	}

	if ((torqueref >= UdcParam.max)|(torqueref <= UdcParam.min)){ // Criterion for saturation

		UdcParam.inLimit=1;
	}
	else{

		UdcParam.inLimit=0;
	}

	return torqueref_return;
}

const fp32_t TorqueLimiter::Current(const fp32_t torqueref,const fp32_t currentLimStator,const fp32_t PsiMax){
 // This routine is different for the different type of machines. Here we have Synchronous Machine with Filed winding: SM
	fp32_t torqueref_return;


	CurrentParam.max=fmin(SpeedParam.Te_maxSpeed,PsiMax*currentLimStator);
	CurrentParam.min=fmax(SpeedParam.Te_minSpeed,-PsiMax*currentLimStator);

	torqueref_return=fmin(torqueref,CurrentParam.max);
	torqueref_return=fmax(torqueref_return,CurrentParam.min);

	if ((torqueref >= CurrentParam.max)|(torqueref <= CurrentParam.min)){ // Criterion for saturation

		CurrentParam.inLimit=1;
	}
	else{

		CurrentParam.inLimit=0;
	}

	return torqueref_return;
}

const fp32_t TorqueLimiter::Power(const fp32_t torqueref,const fp32_t speed,const fp32_t PowerLimMotor, const fp32_t PowerLimGen ){

	fp32_t torqueref_return;
	fp32_t power_motor;
	fp32_t power_generator;

	power_motor		= fmin(PowerLimMotor,PowerParam.P_max);
	power_generator	= fmax(PowerLimGen,PowerParam.P_min);

	if (speed >= 0.0){
		PowerParam.max=fmin(SpeedParam.Te_maxSpeed,power_motor/fmax(speed,0.1));
		PowerParam.min=fmax(SpeedParam.Te_minSpeed,power_generator/fmax(speed,0.1));
	}
	else{ // speed < 0
		PowerParam.max=fmin(SpeedParam.Te_maxSpeed,-power_generator/fmax(-speed,0.1));
		PowerParam.min=fmax(SpeedParam.Te_minSpeed,-power_motor/fmax(-speed,0.1));
	}

	if ((torqueref >= PowerParam.max)|(torqueref <= PowerParam.min)){ // Criterion for saturation

		PowerParam.inLimit=1;
	}
	else{

		PowerParam.inLimit=0;
	}

	torqueref_return=fmax(fmin(torqueref,PowerParam.max),PowerParam.min);

	return torqueref_return;


}

void TorqueLimiter::Filter(const fp32_t torque_lim_max,const fp32_t torque_lim_min){

	m_Tmax_k_1 = Tmax_k;
	Tmax_k   = fmin(m_Tmax_k_1+m_Tlim_increase,torque_lim_max);

	m_Tmin_k_1 = Tmin_k;
	Tmin_k   = fmax(m_Tmin_k_1-m_Tlim_increase,torque_lim_min);

}

void TorqueLimiter::FilterSetValue(const fp32_t torque_lim_max,const fp32_t torque_lim_min){

	Tmax_k  =torque_lim_max;
	m_Tmax_k_1=torque_lim_max;
	Tmin_k  =torque_lim_min;
	m_Tmin_k_1=torque_lim_min;

}


