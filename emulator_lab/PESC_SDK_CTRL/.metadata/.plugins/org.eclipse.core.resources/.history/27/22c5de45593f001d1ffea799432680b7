
/************************************************************************************

File Name: 		Drive.cpp
Description:	Implementation code. Further details explained in Drive.hpp

NOTE:  This version is for DC Drives

*************************************************************************************/


#include "Drive.hpp"

void Drive::initialize(void){


	Parameters.Drive1.MotorData.MACHINE_ID =static_cast<e_DRIVE_ID>(Parameters.Drive1.MotorData.Machine_Type);
	fp32_t help1;
	m_udc_test = 1.0;
	m_speed_max = 1.5;
	m_speed_rate_sign = 1.0;

	m_i.a_avg_old    = 0.0;
	m_Udc1_Startup_V = Parameters.Drive1.DriveData.Udc_conv1_StartLim_V;
	m_Udc2_Startup_V = Parameters.Drive1.DriveData.Udc_conv2_StartLim_V;
	m_UfN            = Parameters.Drive1.MotorData.UfN_V;
	m_UaN			 = Parameters.Drive1.MotorData.UaN_V;
	Parameters.Drive1.MotorData.Uabasis_V  = Parameters.Drive1.MotorData.UaN_V-Parameters.Drive1.MotorData.Ra_Ohm*Parameters.Drive1.MotorData.IaN_A ;
	m_Uabasis        = Parameters.Drive1.MotorData.Uabasis_V;
	m_1_div_IaN		 = 1.0 / Parameters.Drive1.MotorData.IaN_A;
	m_1_div_IfN		 = 1.0 / Parameters.Drive1.MotorData.IfN_A;
	m_1_div_Nrpmbasis = 1.0 / Parameters.Drive1.MotorData.Nn_rpm;
	m_1_div_UfN      = 1.0 / m_UfN;
	m_1_div_Uabasis  = 1.0 / m_Uabasis;
	m_1_div_UaN		 = 1.0 / m_UaN;
	m_Tbasis_Nm		 = m_Uabasis * Parameters.Drive1.MotorData.IaN_A /( Parameters.Drive1.MotorData.Nn_rpm * M_PI / 30.0 );

	m_TrefLim.initialize(m_1_div_Uabasis); // Inverse of Udc-basis required
	m_te.max_used = m_TrefLim.Tmax_k;
	m_te.min_used = m_TrefLim.Tmin_k;

	// Reading of machine parameters and calculation of basis-values:

	m_DC.par.ra		 = Parameters.Drive1.MotorData.Ra_Ohm* Parameters.Drive1.MotorData.IaN_A *m_1_div_Uabasis;
	m_DC.par.la		 = Parameters.Drive1.MotorData.La_H* Parameters.Drive1.MotorData.IaN_A *m_1_div_Uabasis;
	m_Ta			 = m_DC.par.la / fmax(m_DC.par.ra, 0.0001);
	m_DC.par.Tf		 = Parameters.Drive1.MotorData.Tf;
	help1=fmax(Parameters.Drive1.DriveData.Factor_Timedelay_field,0.1);
	FieldCurrentController.SetParameters(m_DC.par.Tf/(help1*Tsamp), m_DC.par.Tf, 0.1 * m_DC.par.Tf,0.0, Tsamp);
	help1=fmax(Parameters.Drive1.DriveData.Factor_Timedelay_armature,0.1);
	ArmatureCurrentController.SetParameters(m_DC.par.la /(help1*Tsamp), m_Ta, 0.1*m_Ta,1.0, Tsamp); // la is probably wrong, so changed the gain from 4.0xTsamp to 1.0xTsamp

	m_DC.par.iamax0   = Parameters.Drive1.MotorData.iamax_pu;
	m_DC.par.ifmax0   = Parameters.Drive1.MotorData.ifmax_pu;
	m_i.limit_motor1  = m_DC.par.iamax0;
	m_i.limit_motor2  = m_DC.par.ifmax0;
	m_te.max_Current1 = 1.0;
	m_ua_fw			  = 1.0+m_DC.par.ra;
	m_i.limit_converter1 = m_1_div_IaN*Parameters.Converter1.Limit.Ia_A;

	// Initialize parameters and limit values for Pull-out Torque Limiter:

	m_SpeedFilter.InitValue(0.0);
	m_SpeedFilter.SetParameters(Parameters.Drive1.DriveData.Time_SpeedFilter, Tsamp); // 3 ms time constant


	m_Converter1_Topology = Parameters.Converter1.Converter_Topology;
	if (m_Converter1_Topology==2) { // Only converter 1 is used for FB+HB
		m_i.limit_converter2 = m_1_div_IfN*Parameters.Converter1.Limit.Ic_A;
	}
	else {
		m_i.limit_converter2 = m_1_div_IfN*Parameters.Converter2.Limit.Ia_A;
	}

}

const bool Drive::resetFaultWord(void){
// To be improved . Should call converter routines as well
	  m_uFaultWord.all = 0x0000;
	  m_uStatusWord.all = 0x0000;

	  if (Converter1.resetFaultWord()&Converter1.resetFaultWord()){ //Only one Converter
		  b_Reset_Fault_Status=true;
	  }
	  else {
		  b_Reset_Fault_Status=false;
	  }

	  return b_Reset_Fault_Status;
}

void Drive::PreCharge(const bool Relay_on){
// Controlling the pre-charge relays for the converters
	b_Precharge_On_Converter1=Relay_on;
	b_Precharge_On_Converter2=Relay_on;
}

const uint16_t Drive::ReadyToStart(void){
	m_Bit_Status = m_uStatusWord.bit.ready_to_start;
	return m_Bit_Status;
}

const uint16_t Drive::ReadyForOperationEnable(void){
	m_Bit_Status = m_uStatusWord.bit.ready_for_operation_enable;
	return m_Bit_Status;
}

const ValueActual Drive::GetValues(void){

	m_actualvalues.te_ref_used = m_te.ref_used;
	m_actualvalues.te_actual   = m_te.actual;
	m_actualvalues.speed       = m_speed_filtered_pu; //m_speed_pu;
	m_actualvalues.speed_filtered = m_speed_filtered_pu;
	m_actualvalues.te_max_used = m_te.max_used;
	m_actualvalues.te_min_used = m_te.min_used;
	return m_actualvalues;
}


void Drive::SetValues(ValueRef References){ // Get references and limits from Application Layer into  Drive Layer

	m_te.ref_input	=	References.te_ref; // Reference.ref instead of ValueRef.ref
	m_te.max		=	References.te_max; // Reference.max instead of ValueRef.max
	m_te.min		=	References.te_min;
	m_p.max			=	fabs(References.p_max);
	m_p.min			=  -fabs(References.p_min);

}

const uDriveFaultWord Drive::GetFaults(void){
	return m_uFaultWord;
}

const uDriveWarningWord Drive::GetWarnings(void){
	return m_uWarningWord;
}

const uDriveLimitWord Drive::GetLimits(){
	return m_uLimitWord;
}


void Drive::getMeasurements(void){

	m_conv1 = Converter1.getMeasurements();
	m_conv2 = Converter2.getMeasurements();

}


const uint16_t Drive::getStatus(const uint16_t conv1, const uint16_t conv2){
	uint16_t drive_has_tripped;

	if ((!conv1)&(!conv2)){
		drive_has_tripped = false;

	}
	else{ // Only SET Fault-bit. Never clear it.
		drive_has_tripped = true;
		if (conv1) m_uFaultWord.bit.converter_1 = true;
		if (conv2) m_uFaultWord.bit.converter_2 = true;
	}

	return drive_has_tripped;
}




void Drive::RequestState(enum DriveState drive_status){
	// Here conditions for changing the state has to be considered and m_state given the proper value

	switch (drive_status){
			case DriveState::Disabled:
				m_state = DriveState::Disabled;
				break;
			case DriveState::Starting:
				m_state = DriveState::Starting;
				break;
			case DriveState::OperationEnabled:
				m_state = DriveState::OperationEnabled;
				break;
			case DriveState::TestRun:
				m_state = DriveState::TestRun;
				break;
			default:
				m_state = DriveState::Disabled;
				break;
		}

}

void Drive::run(void) {

	/*	getFaultAndWarnings();  // From Converters
		if (m_uFaultWord.all !=0){
					m_state = DriveState::Disabled;
		}
	*/

	m_speed_pu = FirmWare1.getSpeed(PhysicalMode) * m_1_div_Nrpmbasis;
	m_theta_el = FirmWare1.getPosition(PhysicalMode);
	m_speed_filtered_pu = m_SpeedFilter.Run(m_speed_pu);

	// calculation of pu-values of measured currents and voltages in armature:
	m_u.dc1			= m_conv1.U_dc_avg_V*m_1_div_Uabasis;
	m_u.a			= (m_conv1.U_a0_avg_V - m_conv1.U_b0_avg_V)*m_1_div_Uabasis;
	m_ua_max 		= m_conv1.U_peak_max_V * m_1_div_Uabasis;

	m_i.a_avg_old   = m_i.a_avg;
	m_i.a_avg   	= m_conv1.I_sa_avg_A * m_1_div_IaN;
	m_i.a_MA		= 0.5*(m_i.a_avg+m_i.a_avg_old);
	m_i.a_LP   		= m_conv1.I_sa_A * m_1_div_IaN;
	m_i.a			= m_i.a_MA; //Chosen feedback from MA

	// calculation of pu-values of measured current and voltage in field winding:

	if (m_Converter1_Topology==2) { // Only converter 1 is used for FB+HB
		m_u.dc2			= m_conv1.U_dc_avg_V*m_1_div_UfN;
		m_u.f			= m_conv1.U_c0_avg_V*m_1_div_UfN;
		m_uf_max 		= m_conv1.U_peak_max_V * m_1_div_UfN; // Could be modified if rated voltage is much less than armature....
		m_i.f_avg_old   = m_i.f_avg;
		m_i.f_avg   	= m_conv1.I_sc_avg_A * m_1_div_IfN;
		m_i.f_MA		= 0.5*(m_i.f_avg+m_i.f_avg_old);
		m_i.f_LP   		= m_conv1.I_sc_A * m_1_div_IfN;
		m_i.f			= m_i.f_MA; //Chosen feedback from MA
	}
	else { // Converter2 as FB in field circuit
		m_u.dc2			= m_conv2.U_dc_avg_V*m_1_div_UfN;
		m_u.f			= (m_conv2.U_a0_avg_V - m_conv2.U_b0_avg_V)*m_1_div_UfN;
		m_uf_max 		= m_conv2.U_peak_max_V * m_1_div_UfN;
		m_i.f_avg_old   = m_i.f_avg;
		m_i.f_avg   	= m_conv2.I_sa_avg_A * m_1_div_IfN;
		m_i.f_MA		= 0.5*(m_i.f_avg+m_i.f_avg_old);
		m_i.f_LP   		= m_conv2.I_sa_A * m_1_div_IfN;
		m_i.f			= m_i.f_MA; //Chosen feedback from MA
	}


	switch (m_state){
		case DriveState::Disabled:
			runState_Disabled();
			break;
		case DriveState::Starting:
			runState_Starting();
			break;
		case DriveState::OperationEnabled:
			runState_Operation_Enabled();
			break;
		case DriveState::TestRun:
			runState_Test_Run();
			break;
		default:
			runState_Disabled();
			break;
	}
}



void Drive::runState_Disabled(void){
	// Converters disabled; request the Disable-state in Converter Layer.
	Converter1.RequestState(Converter::ConverterState::Disabled);
	Converter2.RequestState(Converter::ConverterState::Disabled);

	// Checking for conditions for Ready_To_Switch_On; typical DC-voltage reached a value required before start-up (parameter in database)

	if (!m_uStatusWord.bit.ready_to_start){

		if((m_conv1.U_dc_avg_V >= m_Udc1_Startup_V) & (m_conv2.U_dc_avg_V >= m_Udc2_Startup_V)){
			m_uStatusWord.bit.ready_to_start = true; // Should be cleared in fault-state
		}
	}

	m_mode = 1;
}

void Drive::runState_Starting(void){
	// Run Flystart for the machine.
	// All variables required to be initialized for Flux- and Torque Control will be initialized

	// Flystart();
	// At time being: Disabled Converters.........
	Converter1.RequestState(Converter::ConverterState::Disabled);
	Converter2.RequestState(Converter::ConverterState::Disabled);

	m_mode = 2;

	// When Flystart is completed the bit m_uStatusWord.bit.operation_enabled is set. Then the Drive state machine goes to
	// the state  Drive::runState_Operation_Enabled(), but still be in the ApplicationState::Switched_On state itself.

	m_uStatusWord.bit.operation_enabled = true;
	if (m_uStatusWord.bit.operation_enabled)
	{ // When Flystart is completed go to DriveState::OperationEnabled
		m_state = DriveState::OperationEnabled;
	  //  Initialize all functions here ??
	}


}


void Drive::runState_Operation_Enabled(void){
	// Full Flux- and Torque Control in operation. If the Application state machine still is in Switched_On state, the Torque reference will be zero.
	// When the flux level is reached the Ready_For_Operation _Enable is set. This test should only be made when operation_enable is false.

	fp32_t help1;
	fp32_t help2;
	fp32_t help3;


	/*	if  (m_speed_test > m_speed_max ){
			m_speed_rate_sign=-1.0;
		}
		else if (m_speed_test < -m_speed_max ){
			m_speed_rate_sign=1.0;
		}
		m_speed_test+=m_speed_rate_sign*m_speed_rate;
  */

	Converter1.RequestState(Converter::ConverterState::Enabled);
	Converter2.RequestState(Converter::ConverterState::Enabled);
	m_mode = 3;

	// Speed and position measurements if encoder is available:

	//m_speed_pu = FirmWare1.getSpeed(PhysicalMode) * m_1_div_Nrpmbasis;
	//m_theta_el = FirmWare1.getPosition(PhysicalMode);


	m_DAC.setInput(DAC::CH_B, m_i.a * hmi.dac.DAC_B_sw_pregain);
	m_DAC.setInput(DAC::CH_D, m_te.ref_input * hmi.dac.DAC_D_sw_pregain);
	// m_DAC.setInput(DAC::CH_A, U_sin_ref_A);


	// Motor model:
	m_te.actual		= FirmWare1.getTorque(PhysicalMode);
	m_te.estimated	=m_i.f*m_i.a;


	// Flux reference calculation or controller:

	m_ua_fw_used =abs(fmin(m_ua_fw, m_ua_max));
	m_psi_sref_used =fmin(m_ua_fw_used/fmax(abs(m_speed_pu),0.1) , 1.0);
	m_psi_sref = m_psi_sref_used;

	// Calculate torque reference and torque limits:

	m_te.ref_used =TorqueRefLimitation(m_te.ref_input,m_te.max,m_te.min); // Torque limits due to currents are dependent of which type of motors


	// Calculate torque reference and torque limits:

	m_ia_ref_pu	= m_te.ref_used / fmax( m_i.f, 0.1);

	// Field weakening Control:
	m_if_ref_pu =  m_psi_sref_used;

	// Current controllers:

	m_ref_conv1.Us_peak_V = m_UaN * ArmatureCurrentController.Run(m_ia_ref_pu, m_i.a,m_speed_pu*m_i.f, -m_ua_max, m_ua_max);
	//m_ref_conv1.Us_peak_V = m_UaN * ArmatureCurrentController.Run(hmi.hysteresis_reg.m_ia_ref_pu, m_i.a, m_speed_pu*m_i.f, -m_ua_max, m_ua_max);

	if (m_Converter1_Topology==2) { // Only converter 1 is used for FB+HB. Note: Use angle for transferring voltage command.
		m_ref_conv1.delta_s_s = m_UfN * FieldCurrentController.Run(m_if_ref_pu, m_i.f, 0.0, 0.0, m_uf_max);
		//m_ref_conv1.delta_s_s = m_UfN * FieldCurrentController.Run(hmi.hysteresis_reg.m_if_ref_pu, m_i.f, 0.0, 0.0, m_uf_max);
	}
	else {
		m_ref_conv2.Us_peak_V = m_UfN * FieldCurrentController.Run(m_if_ref_pu, m_i.f, 0.0, -m_uf_max, m_uf_max);
		Converter2.SetValues(m_ref_conv2);
	}

	// Running PWM or hysteresis controller:
	Converter1.SetValues(m_ref_conv1);


	// Check that Flux-level is reached and if so; set DriveStatusBit  ready_for_operation_enable. This is used to set ready_for_operation_enable in Application Layer
	// Can also use a timer increment.....
	m_uStatusWord.bit.ready_for_operation_enable=true;

	// Initialize position sensor ? Apply DC-current in phase A (To be done before ready_for_operation_enable is set.....)
}

void Drive::runState_Test_Run(void){
	// Here Pulse-testing or ID-Run are implemented.

	Converter1.RequestState(Converter::ConverterState::TestRun);
	Converter2.RequestState(Converter::ConverterState::TestRun);
	m_mode = 4;
}


const fp32_t Drive::TorqueRefLimitation(const fp32_t torqueref,const fp32_t tmax_extern_lim,const fp32_t tmin_extern_lim ){
	fp32_t teref_return;
	fp32_t IfLim;
	fp32_t IsLim;
	fp32_t T_UL;
	fp32_t T_LL;


	m_te.ref_speed=m_TrefLim.Speed(torqueref,m_speed_pu);
	m_te.max_speed=m_TrefLim.SpeedParam.max;
	m_te.min_speed=m_TrefLim.SpeedParam.min;
	m_uLimitWord.bit.torque_ref_speed=m_TrefLim.SpeedParam.inLimit;

	m_te.ref_power =m_TrefLim.Power(m_te.ref_speed,m_speed_pu,m_p.max,m_p.min);
	m_te.max_power1=m_TrefLim.PowerParam.max;
	m_te.min_power1=m_TrefLim.PowerParam.min;
	m_uLimitWord.bit.torque_ref_power=m_TrefLim.PowerParam.inLimit;

	m_i.limit_converter1 	= m_1_div_IaN*m_conv1.I_limit_A;
	m_i.limit_converter2 	= m_1_div_IfN*m_conv2.I_limit_A;
	m_i.limit_motor1		= m_DC.CurrentLimitation(m_DC.par.iamax0);        // To be improved later...
	m_i.limit_motor2		= m_DC.FieldCurrentLimitation(m_DC.par.ifmax0);  // To be improved later...
	IsLim =fmin(m_i.limit_converter1,m_i.limit_motor1);
	IfLim =fmin(m_i.limit_converter2,m_i.limit_motor2);

	m_psi_Max  = m_i.f;
	m_te.ref_current =m_TrefLim.Current(m_te.ref_power,IsLim,m_psi_Max);
	m_te.max_Current1=m_TrefLim.CurrentParam.max;
	m_te.min_Current1=m_TrefLim.CurrentParam.min;
	m_uLimitWord.bit.torque_ref_current1=m_TrefLim.CurrentParam.inLimit;

	T_UL=fmin(fmin(m_te.max_speed,m_te.max_power1),m_te.max_Current1);
	T_UL=fmin(T_UL,tmax_extern_lim);
	T_LL=fmax(fmax(m_te.min_speed,m_te.min_power1),m_te.min_Current1);
	T_LL=fmax(T_LL,tmin_extern_lim);

    // Last function in the chain. Shall be able to overrule the current limiter to protect DC-link.
	m_te.ref_udc =m_TrefLim.UdcLink(m_te.ref_current,m_u.dc1,m_speed_pu,T_UL,T_LL);
	m_te.max_udc1=m_TrefLim.UdcParam.max;
	m_te.min_udc1=m_TrefLim.UdcParam.min;
	m_uLimitWord.bit.torque_ref_udc1=m_TrefLim.UdcParam.inLimit;


	// Filtering the used limits:
	m_TrefLim.Filter(m_TrefLim.Tmax_unfiltered,m_TrefLim.Tmin_unfiltered);
	m_te.max_used=m_TrefLim.Tmax_k;
	m_te.min_used=m_TrefLim.Tmin_k;

	//teref_return= fmax( fmin(m_te.ref_udc, m_te.max_used), m_te.min_used);
	teref_return= fmax( fmin(torqueref, m_te.max_used), m_te.min_used);

	return teref_return;
}
