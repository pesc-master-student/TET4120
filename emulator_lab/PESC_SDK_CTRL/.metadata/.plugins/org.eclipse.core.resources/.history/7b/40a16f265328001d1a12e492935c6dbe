// Include files
#include <stdlib.h>					//  Standard Library
#include <stdio.h>					// Standard IO library
#include <Cmath>				    // Math Library
#include <types.hpp>
#include <constants.hpp>
#include "SystemSWpar.h"
#include "ConfigParameters.hpp"

[[gnu::section(".config_parameters")]] // Parameters are stored in a special memory section
ConfigParameters Parameters;

void GetParameters()
{   // Modification of default data and data from Database :
	//------------------------------------------------------

	//System parameters:
	//==================

/*	// Percent of Tsamp used by the interrupt:
	Parameters.System1.percent_Time_interrupt_Warning =80.0; // in %
	Parameters.System1.percent_Time_interrupt_Fault   =90.0;
*/


	// Converter 1: Armature winding
	//==============================
	Parameters.Converter1.ADC.bit_per_A_a		= 16.384; // N=2 R=6
	Parameters.Converter1.ADC.bit_per_A_b		= 16.384; // N=2 R=6
	Parameters.Converter1.ADC.bit_per_A_c		= 819.2;  //N=20  R=30  N*R*2048/(2000*0.75)
	Parameters.Converter1.ADC.bit_per_V			= 5.12;   // 400V 25 mA     25mA*30*2048/(400 V*750 mV)
	Parameters.Converter1.FWTripp.Ia_A			= 120.0;
	Parameters.Converter1.FWTripp.Ib_A			= 120.0;
	Parameters.Converter1.FWTripp.Ic_A			= 2.4;	  //Field current. Should be larger than Fault value (SW)
	Parameters.Converter1.FWTripp.Udc_V			= 350.0;
	Parameters.Converter1.Warning.Ia_A			= 100.0;
	Parameters.Converter1.Warning.Ib_A			= 100.0;
	Parameters.Converter1.Warning.Ic_A			= 2.1;
	Parameters.Converter1.Warning.Udc_max_V		= 330.0;
	Parameters.Converter1.Warning.Udc_min_V 	= 200.0;
	Parameters.Converter1.Fault.Ia_A			= 110.0;
	Parameters.Converter1.Fault.Ib_A			= 110.0;
	Parameters.Converter1.Fault.Ic_A			= 2.3;
	Parameters.Converter1.Limit.Ia_A			= 100.0;
	Parameters.Converter1.Limit.Ib_A			= 100.0;
	Parameters.Converter1.Limit.Ic_A			=  2.0;
	Parameters.Converter1.Fault.Udc_min_V   	= 150.0;
	Parameters.Converter1.Converter_Topology= 2;		// 1:Full-Bridge (HB) 2:Full-Bridge (HB)+Half-Bridge (HB)

	// Converter 2: Field winding (Full-Bridge case)
	//==================================================
	Parameters.Converter2.ADC.bit_per_A_a 	= 819.2;  	//N=20  R=30  N*R*2048/(2000*0.75)
	Parameters.Converter2.ADC.bit_per_A_b 	= 819.2;
	Parameters.Converter2.ADC.bit_per_A_c 	= 819.2;
	Parameters.Converter2.ADC.bit_per_V	 	= 5.12;
	Parameters.Converter2.FWTripp.Ia_A		= 2.4;
	Parameters.Converter2.FWTripp.Ib_A		= 2.4;
	Parameters.Converter2.FWTripp.Ic_A		= 2.4;
	Parameters.Converter2.FWTripp.Udc_V		= 350.0;
	Parameters.Converter2.Warning.Ia_A		=  15.0;
	Parameters.Converter2.Warning.Ib_A		=  15.0;
	Parameters.Converter2.Warning.Ic_A		=  15.0;
	Parameters.Converter2.Warning.Udc_max_V =  90.0;
	Parameters.Converter2.Warning.Udc_min_V =  50.0;
	Parameters.Converter2.Fault.Ia_A		=  18.0;
	Parameters.Converter2.Fault.Ib_A		=  18.0;
	Parameters.Converter2.Fault.Ic_A		=  18.0;
	Parameters.Converter2.Limit.Ia_A		=  10.0;
	Parameters.Converter2.Limit.Ib_A		=  10.0;
	Parameters.Converter2.Limit.Ic_A		=  10.0;
	Parameters.Converter2.Fault.Udc_min_V	=  40.0;    // Why not 150 V as for converter 1 ?? To be tested
	Parameters.Converter2.Converter_Topology=  1;   	// FB

	// Application Layer:
	//===================
/*
	// Reference Sources and Control Mode:
	Parameters.App1.SourceReference				=0;   // 0: WatchView  1: ModBus
	Parameters.App1.ControlMode				    =1;   // 0: Torque  1: Speed    2: Power   3: DC-link Voltage   4: Load Emulator

	// IDRun and Pulse test:
	Parameters.App1.b_PulseTest_request 		= false;
	Parameters.App1.b_IDRun_request 			= false;

	// Remote control mode selection:
	Parameters.App1.b_Remote_Allowed 			= false;

	// Reference filters:
	Parameters.App1.TorqueRefFilterTimeConstant  = 0.1;
	Parameters.App1.TorqueRamp.time_increase     = 1.0;
	Parameters.App1.TorqueRamp.time_decrease     = 0.2;
	Parameters.App1.TorqueRamp.deviation_max     = 0.2;      // pu. Stop integration due to big deviation from actual torque
	Parameters.App1.TorqueRamp.error_max         = 0.05;     // pu. Switching between integral and lowpass filtering
	Parameters.App1.b_Torqueramp_Allowed         = true;
	Parameters.App1.b_Torqueramp_Fixed_Selected  = true;
	Parameters.App1.Torque_max					=   1.1;
	Parameters.App1.Torque_min					=  -1.1;

	Parameters.App1.SpeedRefFilterTimeConstant  = 0.25;      // Equal Ti in speed controller
	Parameters.App1.SpeedRamp.time_increase     = 5.0;
	Parameters.App1.SpeedRamp.time_decrease     = 3.0;
	Parameters.App1.SpeedRamp.deviation_max     = 0.05;     // pu. Stop integration due to big deviation from actual speed
	Parameters.App1.SpeedRamp.error_max         = 0.02;     // pu. Switching between integral and lowpass filtering
	Parameters.App1.b_Speedramp_Allowed         = true;
	Parameters.App1.b_Speedramp_Fixed_Selected  = true;

	Parameters.App1.PowerRefFilterTimeConstant	= 0.25;
	Parameters.App1.PowerRamp.time_increase    	= 5.0;
	Parameters.App1.PowerRamp.time_decrease     = 3.0;
	Parameters.App1.PowerRamp.deviation_max     = 0.05;     // pu. Stop integration due to big deviation from actual speed
	Parameters.App1.PowerRamp.error_max         = 0.02;     // pu. Switching between integral and lowpass filtering
	Parameters.App1.b_Powerramp_Allowed         = true;
	Parameters.App1.b_Powerramp_Fixed_Selected  = true;
	Parameters.App1.Power_max					=  1.3;
	Parameters.App1.Power_min					= -1.3;

	Parameters.App1.UdcRefFilterTimeConstant    = 0.25;      // Equal Ti in DC-link votlage controller ?
	Parameters.App1.UdcRamp.time_increase       = 5.0;
	Parameters.App1.UdcRamp.time_decrease       = 3.0;
	Parameters.App1.UdcRamp.deviation_max       = 0.05;     // pu. Stop integration due to big deviation from actual speed
	Parameters.App1.UdcRamp.error_max           = 0.02;     // pu. Switching between integral and lowpass filtering
	Parameters.App1.b_Udcramp_Allowed           = true;
	Parameters.App1.b_Udcramp_Fixed_Selected    = true;
	Parameters.App1.b_UDCref_V_extern_selected 	= false;
	Parameters.App1.Udc_ref_V_local				=  200.0; // Volt
	Parameters.App1.Udc_ref_V_Offset       		=    0.0; // Volt
	Parameters.App1.Udcref_V_max				=  220.0;
	Parameters.App1.Udcref_V_min				=  180.0;

	// Quick Stop Ramp-filter: (time_decrease important)

	Parameters.App1.SpeedQuickStopRamp.time_increase     = 2.0;
	Parameters.App1.SpeedQuickStopRamp.time_decrease     = 2.0;      // The important value.
	Parameters.App1.SpeedQuickStopRamp.deviation_max     = 0.2;      // pu. Stop integration due to big deviation from actual torque
	Parameters.App1.SpeedQuickStopRamp.error_max         = 0.05;     // pu. Switching between integral and lowpass filtering
	Parameters.App1.Speed_Quick_Stop_limit_pu            = 0.05;     // Goes from Quick Stop Stae to Disabled state


	// Controllers:
	Parameters.App1.SpeedController.Kp			= 5.0;
	Parameters.App1.SpeedController.Kv			= 0.0;
	Parameters.App1.SpeedController.Ti			= 0.25;
	Parameters.App1.SpeedController.Ta			= 0.025;

	Parameters.App1.UdcController.Kp			= 5.0;
	Parameters.App1.UdcController.Kv			= 0.0;
	Parameters.App1.UdcController.Ti			= 0.25;
	Parameters.App1.UdcController.Ta			= 0.025;
	Parameters.App1.PG_ref_pu					=   0.0;
	Parameters.App1.k_droop_PG					=   0.0; // In pu
*/
	// Drive Layer:
	//=============

    // Pre-charge Values:
	Parameters.Drive1.DriveData.Udc_conv1_StartLim_V 	= 270.0;
	Parameters.Drive1.DriveData.Udc_conv2_StartLim_V 	= 270.0;

	// Parameter for torque limiter functions:
	Parameters.Drive1.DriveData.Speed_max				=  1.3;
	Parameters.Drive1.DriveData.Speed_min				= -1.3;
	Parameters.Drive1.DriveData.dT_dSpeed				=  10.0;

	Parameters.Drive1.DriveData.Udc_max_V				=  400.0;  // Converted to pu-value another place...
	Parameters.Drive1.DriveData.Udc_min_V				=  150.0;
	Parameters.Drive1.DriveData.dT_dUdc					=  20.0; // Both torque and voltage in pu, i.e. this is a pu-value
	Parameters.Drive1.DriveData.Te_maxUdc				=  0.2;
	Parameters.Drive1.DriveData.Te_minUdc				= -0.2;

	Parameters.Drive1.DriveData.P_max					=  1.2;   //pu
	Parameters.Drive1.DriveData.P_min					= -0.9;   // Can even be set to zero
	Parameters.Drive1.DriveData.Te_max					=  1.5;   // Max allowed torque in pu of the motor drive
	Parameters.Drive1.DriveData.Te_min					= -1.5;
	Parameters.Drive1.DriveData.Tlim_slope_filter       =  0.5;   // time to increase to 1 pu torque [s]
	//Parameters.Drive1.DriveData.Time_SpeedFilter		=  0.003;  // Tf,n in the compendium

	// Motor data:
	Parameters.Drive1.MotorData.MACHINE_ID =  DC_DRIVE;

	Parameters.Drive1.MotorData.UaN_V      = 220.0;
	Parameters.Drive1.MotorData.IaN_A      = 51.0;
	Parameters.Drive1.MotorData.UfN_V      = 182.4;				// UfN=Rf*IfN=114*1.6=182.4
	Parameters.Drive1.MotorData.IfN_A      = 1.6;
	Parameters.Drive1.MotorData.Nn_rpm     = 2100.0;
	Parameters.Drive1.MotorData.ra         = 0.06152;            // [pu]
	Parameters.Drive1.MotorData.la         = 0.000455247;        // [s]
	Parameters.Drive1.MotorData.Tf         = 0.070;              // [s]
	Parameters.Drive1.MotorData.Uabasis_V  = Parameters.Drive1.MotorData.UaN_V/(1.0+Parameters.Drive1.MotorData.ra);
	Parameters.Drive1.MotorData.polepairs  = 1;
	Parameters.Drive1.MotorData.iamax_pu	= 1.5;
	Parameters.Drive1.MotorData.ifmax_pu	= 2.0;  // Not used in code now. Limited to 1.0 pu flux.

	// SW Load Emulator data: Emulation of Load Torque
	//=================================================
	// Different types of loads can be emulated.
	// The calculated load torque can be used either as load for the FirmWare Emulator
	// OR as torque reference in Load Emulator Mode in the Application Layer.

	/* Parameters.Load1.LoadType		   = 0;
	Parameters.Load1.Pump.k_L		   = 0.8;
	Parameters.Load1.Pump.t_constant   = 0.0;
    */


	// FirmWare Emulator data: DC machine MACHINE_ID=1
	//=================================================
	// Machine data is calculated based on motor data from the Drive Layer
	//Parameters.FW1.Emulator.MACHINE_ID = Parameters.Drive1.MotorData.MACHINE_ID;
	Parameters.FW1.Emulator.Udc1_V = 280.0;
	Parameters.FW1.Emulator.Udc2_V = 280.0;
	Parameters.FW1.Emulator.Tm = 2.0;
	Parameters.FW1.Emulator.kn = 1.0;

}

